name: build-and-push

on:
  push:
    branches: [ main, rafa, ele, fran ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ROLE_ARN: ${{ secrets.AWS_ROLE_TO_ASSUME }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Now (UTC) for build metadata
        id: now
        run: echo "now=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Decide image tag & service by branch
        id: map
        run: |
          case "${GITHUB_REF_NAME}" in
            main) TAG=main ; SVC=origin-insights-llm-main ;;
            rafa) TAG=rg   ; SVC=origin-insights-llm-rafa ;;
            ele)  TAG=er   ; SVC=origin-insights-llm-ele  ;;
            fran) TAG=ff   ; SVC=origin-insights-llm-fran ;;
            *) echo "Branch no mapeada: ${GITHUB_REF_NAME}"; exit 1 ;;
          esac
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "svc=$SVC" >> "$GITHUB_OUTPUT"

      # --- build SIN CACHE + build-args ---
      - name: Build image (no cache) with metadata
        run: |
          docker build --no-cache \
            --build-arg BUILD_SHA="${GITHUB_SHA}" \
            --build-arg BUILD_REF="${GITHUB_REF_NAME}" \
            --build-arg BUILD_TIME="${{ steps.now.outputs.now }}" \
            -t "${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}" .

      # --- sanity: la imagen TIENE las env BUILD_* ---
      - name: Inspect image env (debug)
        run: |
          docker inspect "${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}" \
            --format '{{range .Config.Env}}{{println .}}{{end}}' | grep -E '^BUILD_(SHA|REF|TIME)=' || true

      - name: Tag & push
        run: |
          IMAGE_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}"
          docker tag "${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}" "$IMAGE_URI"
          docker push "$IMAGE_URI"

      - name: Show pushed digest (debug)
        run: |
          aws ecr describe-images \
            --repository-name "${{ env.ECR_REPOSITORY }}" \
            --image-ids imageTag=${{ steps.map.outputs.tag }} \
            --query "imageDetails[0].[imageDigest,imagePushedAt]" --output table

      # --- Deploy en App Runner ---
      - name: Maybe start App Runner deployment (only when RUNNING)
        id: kick
        shell: bash
        run: |
          set -euo pipefail
          SVC="${{ steps.map.outputs.svc }}"
          ARN=$(aws apprunner list-services --region "${{ env.AWS_REGION }}" \
                 --query "ServiceSummaryList[?ServiceName=='${SVC}']|[0].ServiceArn" --output text)
          echo "Service ARN: $ARN"

          STATUS=$(aws apprunner describe-service --region "${{ env.AWS_REGION }}" \
                     --service-arn "$ARN" --query "Service.Status" --output text)
          echo "Service status: $STATUS"

          # Si est√° RUNNING, podemos forzar un deploy manual (opcional)
          if [ "$STATUS" = "RUNNING" ]; then
            echo "Service is RUNNING ‚Üí starting on-demand deployment‚Ä¶"
            aws apprunner start-deployment --region "${{ env.AWS_REGION }}" --service-arn "$ARN" || true
            echo "started=true" >> "$GITHUB_OUTPUT"
          else
            echo "Service not RUNNING ($STATUS). Skipping start-deployment (auto-deploy seguir√° su curso)."
            echo "started=false" >> "$GITHUB_OUTPUT"
          fi


      # --- URL del servicio (usa vars del repo: APPRUNNER_URL_*) ---
      - name: Pick service URL
        id: svc
        run: |
          case "${GITHUB_REF_NAME}" in
            main) url="${{ vars.APPRUNNER_URL_MAIN }}" ;;
            rafa) url="${{ vars.APPRUNNER_URL_RAFA }}" ;;
            ele)  url="${{ vars.APPRUNNER_URL_ELE }}" ;;
            fran) url="${{ vars.APPRUNNER_URL_FRAN }}" ;;
            *) echo "No URL for branch ${GITHUB_REF_NAME}"; exit 1 ;;
          esac
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Install jq (if missing)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      # --- espera health y /version ---
      - name: Wait for healthy & correct version (with diagnostics)
        shell: bash
        run: |
          set -euo pipefail
          url="${{ steps.svc.outputs.url }}"
          target_sha="${GITHUB_SHA}"
          short="${GITHUB_SHA:0:7}"

          echo "Waiting for ${url} to serve build ${target_sha} ..."
          for i in {1..60}; do
            code=$(curl -sS -o /dev/null -w "%{http_code}" "$url/healthz" || true)
            if [ "$code" = "200" ]; then
              got=$(curl -sS "$url/version" | tr -d '\r')
              echo "version: $got"
              # acepta {"sha": "..."} o {"build":"..."} o {"build":"dev"}
              sha=$(echo "$got" | jq -r '.sha // empty' 2>/dev/null || true)
              build=$(echo "$got" | jq -r '.build // empty' 2>/dev/null || true)
              if [ "$sha" = "$target_sha" ] || [ "$sha" = "$short" ] || [ "$build" = "$target_sha" ] || [ "$build" = "$short" ]; then
                echo "‚úÖ Healthy & correct image deployed"
                exit 0
              fi
            fi
            sleep 10
          done

          echo "‚ùå Timeout esperando deploy de ${target_sha} en ${url}"
          echo "üîé Dump de estado App Runner para diagnosticar‚Ä¶"
          SVC="${{ steps.map.outputs.svc }}"
          ARN=$(aws apprunner list-services --region "${{ env.AWS_REGION }}" \
                 --query "ServiceSummaryList[?ServiceName=='${SVC}']|[0].ServiceArn" --output text)
          aws apprunner describe-service --region "${{ env.AWS_REGION }}" --service-arn "$ARN" \
            --query "{Status:Service.Status, AutoDeploy:Service.SourceConfiguration.AutoDeploymentsEnabled, Image:Service.SourceConfiguration.ImageRepository.ImageIdentifier}" --output json || true
          aws apprunner list-operations --region "${{ env.AWS_REGION }}" --service-arn "$ARN" --max-results 5 --output json || true

          exit 1
