name: build-and-push

on:
  push:
    branches: [ main, rafa, ele, fran ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ROLE_ARN: ${{ secrets.AWS_ROLE_TO_ASSUME }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Now (UTC) for build metadata
        id: now
        run: echo "now=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Decide image tag & service by branch
        id: map
        run: |
          case "${GITHUB_REF_NAME}" in
            main) TAG=main ; SVC=origin-insights-llm-main ;;
            rafa) TAG=rg   ; SVC=origin-insights-llm-rafa ;;
            ele)  TAG=er   ; SVC=origin-insights-llm-ele  ;;
            fran) TAG=ff   ; SVC=origin-insights-llm-fran ;;
            *) echo "Branch no mapeada: ${GITHUB_REF_NAME}"; exit 1 ;;
          esac
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "svc=$SVC" >> "$GITHUB_OUTPUT"

      # --- build SIN CACHE + build-args ---
      - name: Build image (no cache) with metadata
        run: |
          docker build --no-cache \
            --build-arg BUILD_SHA="${GITHUB_SHA}" \
            --build-arg BUILD_REF="${GITHUB_REF_NAME}" \
            --build-arg BUILD_TIME="${{ steps.now.outputs.now }}" \
            -t "${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}" .

      # --- sanity: la imagen TIENE las env BUILD_* ---
      - name: Inspect image env (debug)
        run: |
          docker inspect "${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}" \
            --format '{{json .Config.Env}}' | jq -r '.[]' | grep -E '^BUILD_(SHA|REF|TIME)=' || true

      - name: Tag & push
        run: |
          IMAGE_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}"
          docker tag "${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}" "$IMAGE_URI"
          docker push "$IMAGE_URI"

      - name: Show pushed digest (debug)
        run: |
          aws ecr describe-images \
            --repository-name "${{ env.ECR_REPOSITORY }}" \
            --image-ids imageTag=${{ steps.map.outputs.tag }} \
            --query "imageDetails[0].[imageDigest,imagePushedAt]" --output table

      # --- fuerzo deploy en App Runner (por si el auto-deploy está desactivado o tarda en enganchar) ---
      - name: Start App Runner deployment for this branch
        run: |
          ARN=$(aws apprunner list-services --region "${{ env.AWS_REGION }}" \
                 --query "ServiceSummaryList[?ServiceName=='${{ steps.map.outputs.svc }}']|[0].ServiceArn" --output text)
          echo "Service ARN: $ARN"
          aws apprunner start-deployment --region "${{ env.AWS_REGION }}" --service-arn "$ARN"

      # --- URL del servicio (usa vars del repo: APPRUNNER_URL_*) ---
      - name: Pick service URL
        id: svc
        run: |
          case "${GITHUB_REF_NAME}" in
            main) url="${{ vars.APPRUNNER_URL_MAIN }}" ;;
            rafa) url="${{ vars.APPRUNNER_URL_RAFA }}" ;;
            ele)  url="${{ vars.APPRUNNER_URL_ELE }}" ;;
            fran) url="${{ vars.APPRUNNER_URL_FRAN }}" ;;
            *) echo "No URL for branch ${GITHUB_REF_NAME}"; exit 1 ;;
          esac
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Install jq (if missing)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      # --- espera health y que /version tenga este SHA (acepta sha completo o 7 chars) ---
      - name: Wait for healthy & correct version
        run: |
          url="${{ steps.svc.outputs.url }}"
          target_sha="${GITHUB_SHA}"
          echo "Waiting for ${url} to serve build ${target_sha} ..."
          for i in {1..60}; do
            code=$(curl -sS -o /dev/null -w "%{http_code}" "$url/healthz" || true)
            if [ "$code" = "200" ]; then
              got=$(curl -sS "$url/version" | tr -d '\r')
              echo "version: $got"
              sha=$(echo "$got" | jq -r '.sha // .build // empty' 2>/dev/null || true)
              if [ "$sha" = "$target_sha" ] || [ "$sha" = "${target_sha:0:7}" ]; then
                echo "✅ Healthy & correct image deployed"
                exit 0
              fi
            fi
            sleep 10
          done
          echo "❌ Timeout esperando deploy de ${target_sha} en ${url}"
          exit 1