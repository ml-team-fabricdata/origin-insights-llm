name: build-and-push

on:
  push:
    branches: [ main, rafa, ele, fran ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ROLE_ARN: ${{ secrets.AWS_ROLE_TO_ASSUME }}
  # Debe ser SOLO el nombre del repo ECR (sin registry)
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Now (UTC) for build metadata
        id: now
        run: echo "now=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Decide image tag & service by branch
        id: map
        run: |
          case "${GITHUB_REF_NAME}" in
            main) TAG=main ; SVC=origin-insights-llm-main ;;
            rafa) TAG=rg   ; SVC=origin-insights-llm-rafa ;;
            ele)  TAG=er   ; SVC=origin-insights-llm-ele  ;;
            fran) TAG=ff   ; SVC=origin-insights-llm-fran ;;
            *) echo "Branch no mapeada: ${GITHUB_REF_NAME}"; exit 1 ;;
          esac
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "svc=$SVC" >> "$GITHUB_OUTPUT"

      # --------------------------------------------------------------------
      # Build con metadata y etiqueta final en ECR (sin caché)
      # --------------------------------------------------------------------
      - name: Build image (no cache) with metadata
        id: build
        run: |
          IMAGE_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.map.outputs.tag }}"
          echo "Building image: $IMAGE_URI"
          docker build --no-cache \
            --build-arg BUILD_SHA="${GITHUB_SHA}" \
            --build-arg BUILD_REF="${GITHUB_REF_NAME}" \
            --build-arg BUILD_TIME="${{ steps.now.outputs.now }}" \
            -t "$IMAGE_URI" .
          echo "image_uri=$IMAGE_URI" >> "$GITHUB_OUTPUT"
          echo "::notice::Built image for commit $GITHUB_SHA on branch $GITHUB_REF_NAME"

      - name: Inspect image env (debug)
        run: |
          IMAGE_URI="${{ steps.build.outputs.image_uri }}"
          echo "Inspecting $IMAGE_URI for build metadata..."
          docker inspect "$IMAGE_URI" \
            --format '{{range .Config.Env}}{{println .}}{{end}}' | grep -E '^BUILD_(SHA|REF|TIME)=' || echo "No BUILD_* vars found"

      - name: Push image to ECR
        run: |
          IMAGE_URI="${{ steps.build.outputs.image_uri }}"
          echo "Pushing $IMAGE_URI ..."
          docker push "$IMAGE_URI"

      - name: Show pushed digest (debug)
        run: |
          aws ecr describe-images \
            --repository-name "${{ env.ECR_REPOSITORY }}" \
            --image-ids imageTag=${{ steps.map.outputs.tag }} \
            --query "imageDetails[0].[imageDigest,imagePushedAt]" --output table

      # --------------------------------------------------------------------
      # Deploy automático en App Runner
      # --------------------------------------------------------------------
      - name: Maybe start App Runner deployment
        id: maybe_deploy
        run: |
          SVC="${{ steps.map.outputs.svc }}"
          ARN=$(aws apprunner list-services --region "${{ env.AWS_REGION }}" \
                  --query "ServiceSummaryList[?ServiceName=='${SVC}']|[0].ServiceArn" --output text)
          echo "arn=$ARN" >> "$GITHUB_OUTPUT"

          ST=$(aws apprunner describe-service --region "${{ env.AWS_REGION }}" --service-arn "$ARN" \
                 --query "Service.Status" --output text)
          echo "Service status: $ST"

          if [ "$ST" = "RUNNING" ]; then
            echo "Triggering start-deployment..."
            aws apprunner start-deployment --region "${{ env.AWS_REGION }}" --service-arn "$ARN" >/dev/null
            echo "triggered=yes" >> "$GITHUB_OUTPUT"
          else
            echo "Service is not RUNNING ($ST); no start-deployment."
            echo "triggered=no" >> "$GITHUB_OUTPUT"
          fi

      - name: Pick service URL
        id: svc
        run: |
          case "${GITHUB_REF_NAME}" in
            main) url="${{ vars.APPRUNNER_URL_MAIN }}" ;;
            rafa) url="${{ vars.APPRUNNER_URL_RAFA }}" ;;
            ele)  url="${{ vars.APPRUNNER_URL_ELE }}"  ;;
            fran) url="${{ vars.APPRUNNER_URL_FRAN }}" ;;
            *) echo "No URL for branch ${GITHUB_REF_NAME}"; exit 1 ;;
          esac
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Wait for App Runner operation then check /version
        run: |
          ARN="${{ steps.maybe_deploy.outputs.arn }}"
          URL="${{ steps.svc.outputs.url }}"
          TARGET_SHA="${GITHUB_SHA}"
          SHORT="${TARGET_SHA:0:7}"

          echo "Waiting for App Runner operation to finish..."
          for i in {1..60}; do
            OP=$(aws apprunner list-operations --region "${{ env.AWS_REGION }}" --service-arn "$ARN" --max-results 1 \
                  --query "OperationSummaryList[0].Status" --output text 2>/dev/null || echo "NONE")
            echo "  Last operation status: $OP"
            if [ "$OP" != "IN_PROGRESS" ]; then
              break
            fi
            sleep 10
          done

          echo "Waiting for ${URL} to serve build ${SHORT} ..."
          for i in {1..60}; do
            code=$(curl -sS -o /dev/null -w "%{http_code}" "$URL/healthz" || true)
            if [ "$code" = "200" ]; then
              body=$(curl -sS "$URL/version" | tr -d '\r' || echo '{}')
              echo "version: $body"
              sha=$(echo "$body" | jq -r '.sha // .build // empty' 2>/dev/null || true)
              if [ "$sha" = "$TARGET_SHA" ] || [ "$sha" = "$SHORT" ]; then
                echo "Healthy & correct image deployed"
                exit 0
              fi
            fi
            sleep 10
          done

          echo "Timeout esperando deploy de ${SHORT} en ${URL}"
          exit 1
